diff a/services/core_service/src/common_event/listener.rs b/services/core_service/src/common_event/listener.rs	(rejected hunks)
@@ -38,18 +38,17 @@ use asset_sdk::plugin_interface::{
 
 use crate::sys_event::upload_fault_system_event;
 
-const ASSET_DB: &str = "asset.db";
 const BACKUP_SUFFIX: &str = ".backup";
 const ROOT_PATH: &str = "data/service/el1/public/asset_service";
 
-fn delete_on_package_removed(user_id: i32, owner: Vec<u8>) -> Result<bool> {
+fn delete_on_package_removed(owner: Vec<u8>, calling_info: &CallingInfo) -> Result<bool> {
     let mut cond = DbMap::new();
     cond.insert(column::OWNER_TYPE, Value::Number(OwnerType::Hap as u32));
     cond.insert(column::OWNER, Value::Bytes(owner));
     cond.insert(column::IS_PERSISTENT, Value::Bool(false));
     let mut reverse_condition = DbMap::new();
     reverse_condition.insert(column::SYNC_TYPE, Value::Number(SyncType::TrustedAccount as u32));
-    let mut db = Database::build(user_id)?;
+    let mut db = Database::build(calling_info)?;
     let _ = db.delete_datas(&cond, Some(&reverse_condition), false)?;
 
     cond.remove(column::IS_PERSISTENT);
@@ -67,7 +66,7 @@ fn delete_data_by_owner(user_id: i32, owner: *const u8, owner_size: u32) {
     let owner: Vec<u8> = unsafe { slice::from_raw_parts(owner, owner_size as usize).to_vec() };
     let calling_info = CallingInfo::new(user_id, OwnerType::Hap, owner.clone());
     clear_cryptos(&calling_info);
-    let res = match delete_on_package_removed(user_id, owner) {
+    let res = match delete_on_package_removed(owner, &calling_info) {
         Ok(true) => {
             logi!("The owner wants to retain data after uninstallation. Do not delete key in HUKS!");
             Ok(())
@@ -198,10 +197,16 @@ pub(crate) extern "C" fn on_schedule_wakeup() {
 }
 
 fn backup_db_if_accessible(entry: &DirEntry, user_id: i32) -> Result<()> {
-    let from_path = entry.path().with_file_name(format!("{}/{}", user_id, ASSET_DB)).to_string_lossy().to_string();
-    Database::check_db_accessible(from_path.clone(), user_id)?;
-    let backup_path = format!("{}{}", from_path, BACKUP_SUFFIX);
-    fs::copy(from_path, backup_path)?;
+    for db_path in fs::read_dir(format!("{}", entry.path().to_string_lossy()))? {
+        let db_path = db_path?;
+        let db_name = db_path.file_name().to_string_lossy().to_string();
+        if !db_name.ends_with(BACKUP_SUFFIX) {
+            let from_path = db_path.path().to_string_lossy().to_string();
+            Database::check_db_accessible(from_path.clone(), user_id, db_name.clone())?;
+            let backup_path = format!("{}{}", from_path, BACKUP_SUFFIX);
+            fs::copy(from_path, backup_path)?;
+        }
+    }
     Ok(())
 }
 
