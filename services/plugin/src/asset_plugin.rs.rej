diff a/services/plugin/src/asset_plugin.rs b/services/plugin/src/asset_plugin.rs	(rejected hunks)
@@ -13,14 +13,13 @@
  * limitations under the License.
  */
 
-use asset_common::Counter;
-use asset_db_operator::database::{get_path, Database};
-use asset_definition::{log_throw_error, ErrCode, Result};
+use asset_common::{Counter, OwnerType};
+use asset_db_operator::{database::{construct_splited_db_name, get_path, Database}, types::column};
+use asset_definition::{log_throw_error, ErrCode, Extension, Result};
 use asset_log::{loge, logi};
 use asset_sdk::{plugin_interface::{ExtDbMap, IAssetPlugin, IAssetPluginCtx}, Value};
 use std::{
-    cell::RefCell,
-    sync::{Arc, Mutex},
+    cell::RefCell, collections::HashMap, sync::{Arc, Mutex}
 };
 
 /// The asset_ext plugin.
@@ -98,7 +97,16 @@ impl AssetPlugin {
 #[repr(C)]
 pub struct AssetContext {
     /// The asset database instance.
-    pub data_base: Option<Database>,
+    pub data_base: Option<HashMap<String, Database>>,
+    /// The asset databse's user id.
+    pub user_id: i32,
+}
+
+fn get_db_name(attributes: &ExtDbMap) -> std::result::Result<String, u32> {
+    let owner = attributes.get_bytes_attr(&column::OWNER).map_err(|e| e.code as u32)?;
+    let owner_type = attributes.get_enum_attr::<OwnerType>(&column::OWNER_TYPE).map_err(|e| e.code as u32)?;
+    // 通过owner 和owner type 计算数据库名称
+    construct_splited_db_name(owner_type, owner).map_err(|e| e.code as u32)
 }
 
 #[allow(dead_code)]
@@ -107,45 +115,62 @@ impl IAssetPluginCtx for AssetContext {
     fn init(&mut self, user_id: i32) -> std::result::Result<(), u32> {
         // Create database directory if not exists.
         asset_file_operator::create_user_db_dir(user_id).map_err(|e| e.code as u32)?;
+        let dbs = asset_file_operator::get_user_dbs(user_id).map_err(|e| e.code as u32)?;
+        let mut db_map = HashMap::new();
+        for db_name in dbs {
+            let db = Database::build_with_file_name(user_id, &db_name).map_err(|e| e.code as u32)?;
+            db_map.insert(db_name, db);
+        }
 
-        let db = Database::build(user_id).map_err(|e| e.code as u32)?;
-        self.data_base = Some(db);
+        self.data_base = Some(db_map);
+        self.user_id = user_id;
         Ok(())
     }
 
     /// Adds an asset to the database.
     fn add(&mut self, attributes: &ExtDbMap) -> std::result::Result<i32, u32> {
-        self.data_base
-            .as_mut()
-            .ok_or(ErrCode::InvalidArgument as u32)?
-            .insert_datas(attributes)
-            .map_err(|e| e.code as u32)
+        let mut db_map = self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?;
+        let db_name = get_db_name(attributes)?;
+        if db_map.get(&db_name).is_none() {
+            let db = Database::build_with_file_name(self.user_id, &db_name).map_err(|e| e.code as u32)?;
+            db_map.insert(db_name.clone(), db);
+        }
+        if let Some(db) = db_map.get_mut(&db_name) {
+            db.insert_datas(attributes).map_err(|e| e.code as u32)
+        } else {
+            Err(ErrCode::InvalidArgument as u32)
+        }
     }
 
     fn replace(&mut self, condition: &ExtDbMap, attributes: &ExtDbMap) -> std::result::Result<(), u32> {
-        self.data_base
-            .as_mut()
-            .ok_or(ErrCode::InvalidArgument as u32)?
-            .replace_datas(condition, false, attributes)
-            .map_err(|e| e.code as u32)
+        let db_map = self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?;
+        let db_name = get_db_name(attributes)?;
+        if let Some(db) = db_map.get_mut(&db_name) {
+            db.replace_datas(condition, false, attributes).map_err(|e| e.code as u32)
+        } else {
+            Err(ErrCode::InvalidArgument as u32)
+        }
     }
 
     /// Queries the asset database.
     fn query(&mut self, attributes: &ExtDbMap) -> std::result::Result<Vec<ExtDbMap>, u32> {
-        self.data_base
-            .as_mut()
-            .ok_or(ErrCode::InvalidArgument as u32)?
-            .query_datas(&vec![], attributes, None, false)
-            .map_err(|e| e.code as u32)
+        let db_map = self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?;
+        let db_name = get_db_name(attributes)?;
+        if let Some(db) = db_map.get_mut(&db_name) {
+            db.query_datas(&vec![], attributes, None, false).map_err(|e| e.code as u32)
+        } else {
+            Err(ErrCode::InvalidArgument as u32)
+        }
     }
 
     /// Removes an asset from the database.
     fn remove(&mut self, attributes: &ExtDbMap) -> std::result::Result<i32, u32> {
-        self.data_base
-            .as_mut()
-            .ok_or(ErrCode::InvalidArgument as u32)?
-            .delete_datas(attributes, None, false)
-            .map_err(|e| e.code as u32)
+        let db_map = self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?;
+        let mut total_remove_count = 0;
+        for (_, db) in db_map.iter_mut() {
+            total_remove_count += db.delete_datas(attributes, None, false).map_err(|e| e.code as u32)?;
+        }
+        Ok(total_remove_count)
     }
 
     /// Remove assets from the database with sepcific condition.
@@ -153,40 +178,43 @@ impl IAssetPluginCtx for AssetContext {
         &mut self, specific_cond: &str,
         condition_value: &[Value]
     ) -> std::result::Result<i32, u32> {
-        self.data_base
-            .as_mut()
-            .ok_or(ErrCode::InvalidArgument as u32)?
-            .delete_specific_condition_datas(specific_cond, condition_value)
-            .map_err(|e| e.code as u32)
+        let db_map = self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?;
+        let mut total_remove_count = 0;
+        for (_, db) in db_map.iter_mut() {
+            total_remove_count += db.delete_specific_condition_datas(specific_cond, condition_value).map_err(|e| e.code as u32)?;
+        }
+        Ok(total_remove_count)
     }
 
     /// Updates the attributes of an asset in the database.
     fn update(&mut self, attributes: &ExtDbMap, attrs_to_update: &ExtDbMap) -> std::result::Result<i32, u32> {
-        self.data_base
-            .as_mut()
-            .ok_or(ErrCode::InvalidArgument as u32)?
-            .update_datas(attributes, false, attrs_to_update)
-            .map_err(|e| e.code as u32)
-    }
-
-    /// Begins a transaction for the asset database.
-    fn begin_transaction(&mut self) -> std::result::Result<(), u32> {
-        self.data_base
-            .as_mut()
-            .ok_or(ErrCode::InvalidArgument as u32)?
-            .exec("begin immediate")
-            .map_err(|e| e.code as u32)
-    }
-
-    /// Commits a transaction for the asset database.
-    fn commit_transaction(&mut self) -> std::result::Result<(), u32> {
-        self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?.exec("commit").map_err(|e| e.code as u32)
+        let db_map = self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?;
+        let db_name = get_db_name(attributes)?;
+        if let Some(db) = db_map.get_mut(&db_name) {
+            db.update_datas(attributes, false, attrs_to_update).map_err(|e| e.code as u32)
+        } else {
+            Err(ErrCode::InvalidArgument as u32)
+        }
     }
 
-    /// Rolls back a transaction for the asset database.
-    fn rollback_transaction(&mut self) -> std::result::Result<(), u32> {
-        self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?.exec("rollback").map_err(|e| e.code as u32)
-    }
+    // /// Begins a transaction for the asset database.
+    // fn begin_transaction(&mut self) -> std::result::Result<(), u32> {
+    //     self.data_base
+    //         .as_mut()
+    //         .ok_or(ErrCode::InvalidArgument as u32)?
+    //         .exec("begin immediate")
+    //         .map_err(|e| e.code as u32)
+    // }
+
+    // /// Commits a transaction for the asset database.
+    // fn commit_transaction(&mut self) -> std::result::Result<(), u32> {
+    //     self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?.exec("commit").map_err(|e| e.code as u32)
+    // }
+
+    // /// Rolls back a transaction for the asset database.
+    // fn rollback_transaction(&mut self) -> std::result::Result<(), u32> {
+    //     self.data_base.as_mut().ok_or(ErrCode::InvalidArgument as u32)?.exec("rollback").map_err(|e| e.code as u32)
+    // }
 
     /// Returns the storage path for the asset database.
     fn get_storage_path(&self) -> String {
